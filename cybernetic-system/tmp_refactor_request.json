{
  "model": "policy",
  "prompt": "You are a Senior Elixir Architect and VSM Specialist. Refactor the following Elixir module to be more robust, performant, and maintainable. \\n\\nFocus on:\\n1. Caching: Templates should be cached in an Agent, ETS table, or Persistent Term after the first read to avoid disk I/O.\\n2. Robustness: Handle missing template files with a safe fallback that doesn't just log an error but provides a functional (if minimal) prompt.\\n3. Extensibility: Make it easier to add new template variables.\\n\\nCODE TO REFACTOR:\\ndefmodule Cybernetic.VSM.System4.LLM.Pipeline.Steps.PromptTemplate do\n  @moduledoc \"\"\"\n  Normalize messages and apply templating if needed.\n\n  Converts Episode structs and other formats to normalized message format.\n  \"\"\"\n\n  require Logger\n\n  @doc \"\"\"\n  Normalize messages for LLM consumption.\n  \"\"\"\n  def run(%{episode: episode} = ctx) when not is_nil(episode) do\n    # Convert Episode to messages format\n    messages = episode_to_messages(episode)\n    {:ok, Map.put(ctx, :messages, messages)}\n  end\n\n  def run(%{messages: messages} = ctx) when is_list(messages) do\n    # Normalize existing messages\n    normalized = normalize_messages(messages)\n    {:ok, Map.put(ctx, :messages, normalized)}\n  end\n\n  def run(%{prompt: prompt} = ctx) when is_binary(prompt) do\n    # Simple prompt to messages\n    messages = [%{role: \"user\", content: prompt}]\n    {:ok, Map.put(ctx, :messages, messages)}\n  end\n\n  def run(ctx) do\n    # No messages to process\n    Logger.warning(\"PromptTemplate: No messages to process\")\n    {:ok, ctx}\n  end\n\n  defp episode_to_messages(episode) do\n    # Convert Episode struct to message format\n    system_prompt = build_system_prompt(episode)\n    user_content = build_user_content(episode)\n\n    # Start with system prompt\n    base_messages = [%{role: \"system\", content: system_prompt}]\n\n    # Add historical context messages if they exist\n    context_messages = episode.context[:messages] || []\n\n    # Build final message list: system → context → current user message\n    base_messages ++ context_messages ++ [%{role: \"user\", content: user_content}]\n  end\n\n  defp build_system_prompt(episode) do\n    load_template(\"system_analysis.md\", [\n      {\"kind\", to_string(episode.kind)},\n      {\"priority\", to_string(episode.priority)}\n    ])\n  end\n\n  defp build_user_content(episode) do\n    data_str =\n      case episode.data do\n        data when is_binary(data) -> data\n        data -> inspect(data)\n      end\n\n    metadata_str =\n      if episode.metadata do\n        \"- Metadata: #{inspect(episode.metadata)}\"\n      else\n        \"\"\n      end\n\n    load_template(\"user_analysis.md\", [\n      {\"data\", data_str},\n      {\"source_system\", to_string(episode.source_system)},\n      {\"created_at\", to_string(episode.created_at)},\n      {\"metadata\", metadata_str}\n    ])\n  end\n\n  defp load_template(filename, bindings) do\n    path = Path.join(:code.priv_dir(:cybernetic), \"prompts/#{filename}\")\n\n    case File.read(path) do\n      {:ok, content} ->\n        Enum.reduce(bindings, content, fn {key, value}, acc ->\n          String.replace(acc, \"{{#{key}}}\", to_string(value))\n        end)\n\n      {:error, reason} ->\n        Logger.error(\"Failed to load prompt template #{filename}: #{inspect(reason)}\")\n        \"Error loading prompt template. Bindings: #{inspect(bindings)}\"\n    end\n  end\n\n  defp normalize_messages(messages) do\n    Enum.map(messages, &normalize_message/1)\n  end\n\n  defp normalize_message(%{role: role, content: content} = msg) do\n    %{\n      role: to_string(role),\n      content: to_string(content)\n    }\n    |> maybe_add_name(msg)\n  end\n\n  defp normalize_message(%{\"role\" => role, \"content\" => content} = msg) do\n    %{\n      role: to_string(role),\n      content: to_string(content)\n    }\n    |> maybe_add_name(msg)\n  end\n\n  defp normalize_message(msg) when is_map(msg) do\n    %{\n      role: to_string(msg[:role] || msg[\"role\"] || \"user\"),\n      content: to_string(msg[:content] || msg[\"content\"] || \"\")\n    }\n  end\n\n  defp maybe_add_name(normalized, original) do\n    case original[:name] || original[\"name\"] do\n      nil -> normalized\n      name -> Map.put(normalized, :name, to_string(name))\n    end\n  end\nend\\n\\nOutput ONLY the refactored Elixir code block."
}
