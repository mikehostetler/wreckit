# Research: System Overlay Tool for Static-Dynamic Analysis

**Date**: 2025-01-22
**Item**: 006-system-overlay-tool-for-static-dynamic-analysis

## Research Question
Static analysis shows what code exists, while dynamic traces show what actually executes. We need to correlate these to find dead code (exists but never runs), ghost code (runs but wasn't detected statically), and hot paths (frequently executed code).

**Motivation:** Enables safe dead code removal and architectural hardening by providing data-driven insights about actual code usage versus what's statically present.

**Success criteria:**
- Tool can read and normalize archeology-results.json and dynamic-traces.json
- Dead code candidates identified: static functions never appearing in dynamic traces
- Ghost paths detected: dynamic spans without corresponding static calls
- Coverage metrics calculated per module showing % of static code exercised
- Generates overlay-report.json with structured findings
- Human-readable console summary with dead code, ghost paths, and hot modules

**Technical constraints:**
- Must create Mix.Tasks.Cyb.Overlay
- Input formats: archeology-results.json (static) and dynamic-traces.json (dynamic)
- Filter out known test/callback patterns in dead code detection
- Normalize both data sources into unified graph format

**In scope:**
- Phase 1: Data ingestion and normalization from JSON files
- Phase 2: Diff analysis for dead code, ghost code, and coverage
- Phase 3: Report generation (JSON + console summary)

**Signals:** priority: medium

## Summary

The Cybernetic AMCP system has both static analysis results (from `mix cyb.archeology`) and dynamic execution traces (from `mix cyb.trace`). The archeology results contain 11 traces with 725 orphan functions across 199 Elixir source files, while dynamic traces contain 8 traces with runtime execution spans captured via telemetry. The overlay tool needs to correlate these two datasets to identify discrepancies between what code exists statically versus what actually executes at runtime, providing actionable insights for dead code removal and architectural hardening.

## Current State Analysis

### Existing Implementation

**Static Analysis (archeology-results.json):**
- Generated by `Mix.Tasks.Cyb.Archeology` (`lib/mix/tasks/cyb.archeology.ex:75-103`)
- Contains 11 execution traces from entry points (AMQP, CLI, Telegram, MCP)
- Identifies 725 orphan functions (public functions with zero trace references)
- Structure: `{"traces": [{"entry_point_id": "...", "functions": [...]}], "orphan_functions": [...], "summary": {...}}`

**Dynamic Tracing (dynamic-traces.json):**
- Generated by `Mix.Tasks.Cyb.Trace` (`lib/mix/tasks/cyb.trace.ex:78-170`)
- Captures 8 traces with 8 total spans via `Cybernetic.Archeology.DynamicCollector`
- Uses :telemetry events and OpenTelemetry context
- Structure: `{"traces": [{"trace_id": "...", "spans": [...], "entry_point": {...}}], "summary": {...}}`

**Data Structure Comparison:**
- Static traces: List of function calls per trace with `module`, `function`, `arity`, `file`, `line`, `type`
- Dynamic traces: List of spans per trace with `module`, `function`, `arity`, `file`, `line`, `timestamp`, `duration_us`, `metadata`

### Key Files

**Mix Tasks (patterns to follow):**
- `lib/mix/tasks/cyb.archeology.ex:1-180` - CLI structure, OptionParser, output formatting
- `lib/mix/tasks/cyb.trace.ex:78-170` - Dynamic trace collection and export
- `lib/mix/tasks/cyb.probe.ex:19-224` - Console output patterns with ‚úì/‚úó symbols

**Archeology Modules (for data normalization):**
- `lib/cybernetic/archeology/catalog.ex:1-100` - Function reference types and catalog structure
- `lib/cybernetic/archeology/orphans.ex:1-118` - Test/callback filtering patterns (`is_test_function?/1`, `is_callback_function?/1`)
- `lib/cybernetic/archeology/dynamic_collector.ex:1-564` - Dynamic trace collection and export

**Input Files:**
- `/Users/speed/cybernetic-amcp/archeology-results.json` - 7,475 lines, 11 traces
- `/Users/speed/cybernetic-amcp/dynamic-traces.json` - 224 lines, 8 traces

## Technical Considerations

### Dependencies

**Internal Modules:**
- `Cybernetic.Archeology.Catalog` - Function reference types and utilities
- `Cybernetic.Archeology.Orphans` - Test/callback filtering patterns
- `Jason` - JSON encoding/decoding (already in mix.exs:36)

**External Dependencies:**
- None required (uses existing deps)

### Patterns to Follow

**Mix Task Structure:**
- Use `OptionParser.parse/3` for argument parsing (see `cyb.archeology.ex:76-83`)
- Support `--format=json|elixir` and `--output=PATH` options
- Implement `analyze/0` private function with phase-based pipeline
- Use `Mix.shell().info/1` for console output

**Data Normalization:**
- Normalize both static functions and dynamic spans to unified format: `{module, function, arity}`
- Use MapSets for efficient set operations (dead code detection)
- Group by module for coverage metrics

**Filtering Patterns:**
- Filter test functions: `String.contains?(module_name, "test") or String.contains?(function_name, "test")`
- Filter callbacks: Check against known OTP callback list (`init`, `handle_call`, `handle_cast`, `handle_info`, `terminate`, `code_change`, etc.)
- See `lib/cybernetic/archeology/orphans.ex:83-104` for complete pattern list

**Console Output:**
- Use emoji indicators (‚úì, ‚úó, üìä, üîç) for readability
- Structured sections with box-drawing characters (‚îú, ‚îî)
- Summary statistics at top, detailed findings below

### Data Structures

**Static Function Reference:**
```elixir
%{
  module: "Elixir.Cybernetic.Core.Transport.AMQP",
  function: "publish",
  arity: 2,
  file: "lib/cybernetic/core/transport/amqp.ex",
  line: 120,
  type: "public" | "private" | "unknown"
}
```

**Dynamic Span:**
```elixir
%{
  module: "Elixir.Cybernetic.Core.Transport.AMQP",
  function: "publish",
  arity: 2,
  file: "lib/cybernetic/core/transport/amqp.ex",
  line: 0,
  timestamp: 1769111569267484,
  duration_us: 0,
  metadata: %{event_type: "amqp_publish", routing_key: "..."}
}
```

**Normalized Key:**
```elixir
{module_string, function_string, arity}
# Example: {"Elixir.Cybernetic.Core.Transport.AMQP", "publish", 2}
```

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| **Path normalization mismatch** | Medium | Static traces use absolute paths (`/Users/speed/...`), dynamic traces use relative paths (`lib/cybernetic/...`). Normalize to relative paths for comparison. |
| **Module name format differences** | Low | Both use "Elixir.Fully.Qualified.Module.Name" format. No conversion needed. |
| **False positives in dead code** | Medium | Apply same filtering as Orphans module: test functions, callbacks, and pattern matching on module/function names. |
| **Ghost code from dynamic dispatch** | Low | Dynamic spans may capture code not visible in static analysis (e.g., apply/3, runtime eval). Mark as "dynamic_only" rather than error. |
| **Coverage calculation accuracy** | Low | Coverage = (dynamic functions in module) / (total static functions in module). Filter test/callback functions before calculating. |
| **Large file performance** | Low | archeology-results.json is 7,475 lines (~500KB). Should load in <1 second. Use streaming for very large files if needed. |

## Recommended Approach

### Phase 1: Data Ingestion and Normalization

1. **Create `Mix.Tasks.Cyb.Overlay`** following the pattern in `cyb.archeology.ex`
   - Support `--static=PATH` and `--dynamic=PATH` options (defaults to existing filenames)
   - Support `--format=json|elixir` and `--output=PATH` options
   - Implement verbose mode for debugging

2. **Create `Cybernetic.Archeology.Overlay`** module with three main functions:
   - `load_static_data/1` - Load and parse archeology-results.json
   - `load_dynamic_data/1` - Load and parse dynamic-traces.json
   - `normalize_static_functions/1` - Extract unique `{module, function, arity}` tuples from static traces
   - `normalize_dynamic_spans/1` - Extract unique `{module, function, arity}` tuples from dynamic traces

3. **Normalization Strategy:**
   - Convert all function references to `{module_string, function_string, arity}` tuples
   - Use MapSets for efficient set operations
   - Group static functions by module for coverage calculation
   - Track file paths (normalized to relative) for reporting

### Phase 2: Diff Analysis

1. **Dead Code Detection:**
   - Compute `static_functions - dynamic_functions` (set difference)
   - Filter out test functions (module or name contains "test")
   - Filter out callback functions (init, handle_call, handle_cast, etc.)
   - Result: List of static functions never appearing in dynamic traces

2. **Ghost Path Detection:**
   - Compute `dynamic_functions - static_functions` (set difference)
   - These are functions that execute at runtime but weren't in static traces
   - Mark with metadata about which dynamic trace they appeared in
   - Result: List of dynamic-only functions (likely from dynamic dispatch)

3. **Coverage Metrics:**
   - Group static functions by module
   - For each module: `coverage_pct = (dynamic_functions_in_module / total_static_functions_in_module) * 100`
   - Identify "hot modules" (high execution frequency, high coverage)
   - Identify "cold modules" (low coverage, potential dead code)

### Phase 3: Report Generation

1. **JSON Report (overlay-report.json):**
   ```json
   {
     "summary": {
       "dead_code_count": 123,
       "ghost_path_count": 5,
       "modules_analyzed": 45,
       "avg_coverage_pct": 67.8
     },
     "dead_code": [
       {
         "module": "Elixir.Cybernetic.VSM.System1.Obsolete",
         "function": "old_handler",
         "arity": 1,
         "file": "lib/cybernetic/vsm/system1/obsolete.ex",
         "line": 42
       }
     ],
     "ghost_paths": [
       {
         "module": "Elixir.Cybernetic.DynamicDispatcher",
         "function": "apply_runtime",
         "arity": 3,
         "first_seen_trace": "abc123...",
         "execution_count": 5
       }
     ],
     "module_coverage": [
       {
         "module": "Elixir.Cybernetic.VSM.System4.Intelligence",
         "static_function_count": 25,
         "dynamic_function_count": 20,
         "coverage_pct": 80.0,
         "hot_path": true
       }
     ]
   }
   ```

2. **Console Summary:**
   ```
   üîç Static-Dynamic Overlay Analysis

   üìä Summary:
      ‚îú‚îÄ Dead code candidates: 123 functions
      ‚îú‚îÄ Ghost paths detected: 5 functions
      ‚îú‚îÄ Modules analyzed: 45
      ‚îî‚îÄ Average coverage: 67.8%

   üíÄ Dead Code (Top 10):
      ‚îú‚îÄ Elixir.Cybernetic.VSM.System1.Obsolete.old_handler/1 (obsolete.ex:42)
      ‚îú‚îÄ ...

   üëª Ghost Paths:
      ‚îú‚îÄ Elixir.Cybernetic.DynamicDispatcher.apply_runtime/3 (5 executions)
      ‚îî‚îÄ ...

   üî• Hot Modules (>80% coverage):
      ‚îú‚îÄ Elixir.Cybernetic.VSM.System4.Intelligence (80% - 20/25 functions)
      ‚îî‚îÄ ...

   ‚ùÑÔ∏è  Cold Modules (<20% coverage):
      ‚îú‚îÄ Elixir.Cybernetic.VSM.System1.Obsolete (5% - 1/20 functions)
      ‚îî‚îÄ ...
   ```

### File Structure

```
lib/
  mix/tasks/
    cyb.overlay.ex           # Main Mix task (Phase 3)
  cybernetic/
    archeology/
      overlay.ex              # Overlay analysis logic (Phase 1 & 2)
```

## Open Questions

1. **Path Normalization**: Should we normalize to relative or absolute paths?
   - **Recommendation**: Use relative paths (strip project root) for consistency with dynamic traces

2. **Arity Handling**: Dynamic spans may have `arity: 0` for unknown arities. How to match?
   - **Recommendation**: Treat `arity: 0` as wildcard (matches any arity) in ghost path detection

3. **Multiple Trace Sources**: What if the same function appears in multiple dynamic traces?
   - **Recommendation**: Track execution frequency (count of trace_id occurrences) for hot path detection

4. **Coverage Thresholds**: What defines "hot" vs "cold" modules?
   - **Recommendation**: Hot = >75% coverage, Cold = <25% coverage. Make configurable via CLI options.

5. **Static Trace Depth**: Static traces are depth-limited (default 50). May miss deep code paths.
   - **Recommendation**: Note this limitation in report. Consider flagging functions found dynamically but not statically as "possibly missed due to depth limit" rather than pure "ghost code".
